---
title: "Typst ist mega"
date: 2025-12-12
last_modified_at: 2025-12-12
categories:
  - tools
tags:
  - typst
  - typesetting
excerpt: Meine ersten Erfahrungen mit Typst und Typst Workflows in Github
mathjax: true
header:
  teaser: /assets/images/typst.jpg
---

Ich habe [Typst](https://typst.app) vor ca. zwei Wochen f√ºr mich entdeckt ‚Äì und bin total schockverliebt! üòç

## Was ist Typst?

Typst ist ein Satzsystem und noch so viel mehr. Der eine oder die andere kennt vielleicht TeX/LaTeX noch aus Studienzeiten. Das war/ist wohl _der_ defacto Standard f√ºrs Verfassen wissenschaftlicher Arbeiten. Es ist m√§chtig, aber auch kompliziert. Es gibt unendlich viele B√ºcher √ºber die Benutzung von TeX/LaTeX. F√ºr Typst gibt es nahezu noch keine B√ºcher, soweit ich das sehe (Stand Dezember 2025).

Typst wurde von zwei Deutschen in Berlin erfunden, [Martin Haug](https://github.com/reknih/) und [Laurenz M√§dje](https://github.com/laurmaedje/). Die Software ist [OpenSource](https://github.com/typst/typst) und man kann sie kostenlos benutzen.

## Wie nutzt man Typst?

Da w√§re zun√§chst einmal die Browser basierte Web App unter https://typst.app/app. Sie bietet auch ein Live Preview, so dass man direkt sieht, was man in der `.typ` Datei verzapft.

Ein anderer Weg ist es, sich den Typst Compiler selbst auf seinem Rechner (in meinem Falle also Macs) zu installieren. Das geht am einfachsten mal wieder √ºber Homebrew mit

```shell
brew install typst
```

Jetzt kann man im Texteditor seiner Wahl z.B. die Quelldatei `meindokument.typ` schreiben und dann mit 

```shell
typst compile meindokument.typ
```
daraus die zugeh√∂rige PDF Datei erzeugen.

Typst kann √ºbrigens nicht nur nach PDF exportieren, sondern auch Grafikdateiformate erzeugen. Wenn man also z.B. nur mal eine mathematische Formel in _sch√∂n_ als PNG Datei haben m√∂chte, geht das. Oder ‚Äì wie wir noch sehen werden ‚Äì eine programmierte Illustration als SVG f√ºrs Web? Geht auch. Man kann sogar nach Markdown exportieren, nach HTML oder nach Text. Wobei der HTML Export derzeit wohl noch in den Anf√§ngen steckt, ich habe ihn noch nicht probiert.

## Tipp VSCode

Noch sch√∂ner wird das Arbeiten aber, wenn man sowieso schon [Visual Studio Code](https://code.visualstudio.com) (VSCode) auf dem Rechner hat. Denn dann installiert man sich die Erweiterung [Tinymist Typst](https://marketplace.visualstudio.com/items?itemName=myriad-dreamin.tinymist) und genie√üt eine integrierte, lokale Entwicklungsumgebung mit fast allen Schikanen & Features, von denen der Live Preview nur ein Highlight ist. Das sieht dann ungef√§hr so aus:

{% include figure popup=true image_path="/assets/images/typst-vscode-1.png" alt="Screenshot der Arbeitsumgebung mit Typst und der VSCode Erweiterung Tinymist Typst" caption="Screenshot der Arbeitsumgebung mit Typst und der VSCode Erweiterung Tinymist Typst"%}

Die Erweiterung _Tinymist Typst_ bringt ihr eigenes Typst binary mit. Wenn man sich also f√ºr dieses Setup entscheidet, muss man nicht unbedingt auch selbst √ºber Homebrew Typst lokal installiert haben. Man muss nur wissen, dass die Typst Version, die mit dieser VSCode Erweiterung kommt, nicht immer unbedingt gleichauf mit der zuletzt ver√∂ffentlichten Version von Typst ist. Wenn Typst also in einem Update neue Features bringt, auf die man angewiesen ist bzw. die man unbedingt nutzen will, dann bedeutet dieses Szenario unter Umst√§nden erstmal, dass man etwas Geduld haben muss, bis auch die Tinymist Erweiterung auf den neuesten Stand gebracht wurde.

Man kann zwar in den Einstellungen der Erweiterung auch einen Pfad zu seinem eigenen, lokalen Typst konfigurieren, aber gemeint ist hier nicht das Typst Binary (der Compiler) selbst, sondern Tinymist selbst. Das kann man sich n√§mlich auch √ºber Homebrew installieren (`brew install tinymist`). Ich habe darin aber bis jetzt noch keinen Vorteil erkannt und beschr√§nke mich im Moment f√ºrs lokale Arbeiten an Typst Dokumenten auf die Tinymist VSCode Erweiterung.

## Github

Es kann Gr√ºnde geben, dass man seine Typst Quelldateien (dazu geh√∂ren ja ggfs. auch Bilder oder Fonts) in ein Github Repository legt. So k√∂nnen auch andere lernen, sehen, mitverfolgen, wie man Typst Dokumente schreibt und was alles wie darin funktioniert. Sie k√∂nnen sich dann die Quellen herunterladen und selbst weiter experimentieren.

Oder man hat mehrere Ger√§te, an denen man am selben Dokument arbeiten will und m√∂chte einfach, dass die Dokumente zentral an einem Ort im Internet/in der Cloud liegen. So kann man immer am Ende der Arbeit alles ins Repository hoch pushen und beim Wechsel an ein anderes Ger√§t isch zu Beginn der Arbeit einmal den letzten Stand holen/pullen. Ein Computer mit VSCode und Internet gen√ºgt.

Nat√ºrlich bietet das Arbeiten mit Github vor allem dann auch die M√∂glichkeit, dass mehrere Menschen an ein und dem selben Dokument arbeiten, das k√∂nnte ja z.B. auch ein Buch Projekt sein.

Ich habe mein bisher erstes und einziges Typst Dokument, was ich immer weiter schreibe und dabei Typst lerne, in [dieses Github Repository](https://github.com/metawops/typst) gelegt.

## Ein bisschen Automatisierung

Au√üerdem bietet Github (oder auch andere, √§hnliche Plattformen) nat√ºrlich Workflows zum Automatisieren von Aufgaben. Ich habe mir zwei Workflows eingerichtet:
1. Ein "Build" Workflow, der immer dann zuschl√§gt, sobald ich eine √Ñnderung ins Repository pushe. Dann wird der Typst Compiler _auf Github_ (also innerhalb des Ubuntu Runners) angeworfen und erzeugt das PDF als Artifact. Damit macht der Workflow aber zun√§chst nichts weiter. Wenn ich das PDF brauche, kann ich es mir aus dem Ergebnis des Build Workflows bequem herunterladen:
{% include figure popup=true image_path="/assets/images/typst-github-1.png" alt="Screenshot des Ergebnisses des Build Workflows" caption="Screenshot des Ergebnisses des Build Workflows"%}

1. Ein "Release" Workflow, der immer dann zuschl√§gt, sobald ich in VSCode ein _tag_ vergebe **und** es eine neuere Version der Datei `CHANGELOG.md` gibt, damit ich auch brav Releasenotes pflege.
Es wir dann ein neues Release mit dem vergebenen _tag_ angelegt, welches sowohl die erzeugte PDF Datei enth√§lt, als auch in Form einer ZIP Datei alle zum Erzeugen dieses PDF notwendigen Quelldateien, also v.a. die `.typ` Dateien, aber auch die Fonts und Bilder in ihren jeweiligen Unterordnern.
{% include figure popup=true image_path="/assets/images/typst-github-2.png" alt="Screenshot eines Releases, was der Release Workflow erstellt hat" caption="Screenshot eines Releases, was der Release Workflow erstellt hat"%}

Wie diese beiden Workflows, die im Repository unter `.github/workflows` als `.yml` Datei zu finden sind, gebaut sind, k√∂nnt ihr dort selbst nachschauen, denn das Repository ist ja √∂ffentlich. Hier die Direktlinks: [build-pdf.yml](https://github.com/metawops/typst/blob/main/.github/workflows/build-pdf.yml) und [release.yml](https://github.com/metawops/typst/blob/main/.github/workflows/release.yml).

## Typst als Programmiersprache

Typst ist nicht nur ein Satzsystem, in dem man √§hnlich wie in Markdown oder auch wie mit LaTeX Texte/Dokumente verfassen kann.

Typst ist auch Programmiersprache. Und das er√∂ffnet nat√ºrlich gro√üe Welten! So kann man zum Beispiel Grafiken direkt im Dokument dynamisch erzeugen.

### Tabelle mit errechneten Zahlen
Ein einfaches Beispiel sind die Fibonaccizahlen. M√∂chte man eine Tabelle der ersten 16 Fibonaccizahlen in sein Dokument einbauen, geht das so:

```typst
// Wir definieren eine Funktion, die Fibonaccizahlen errechnen kann:
#let fib(n) = (
  if n <= 2 { 1 }
  else { fib(n - 1) + fib(n - 2) }
)

// Eine Variable f√ºr die Anzahl der Fibonaccizahlen in der Tabelle:
#let count = 16

// Eine Variable, die die Zahlen von 1 bis zu count enth√§lt
#let nums = range(1, count + 1)

// Im Flie√ütext wird an der Stelle von #count der Wert der Variablen count eingesetzt:
Ein gutes Beispiel f√ºr sowohl Tabellen, als auch dass man in Typst selbst dynamisch Inhalte erzeugen kann, ist diese Tabelle mit den ersten #count Fibonaccizahlen.

// Jetzt erzeugen wir eine zentrierte Tabelle mit zwei Zeilen und count Spalten:
#align(center,
   table(
      columns: count,
      fill: (_, row) => if row == 0 { luma(230) } else { none },
      ..nums.map(n => $F_#n$),
      ..nums.map(n => text(orange)[#str(fib(n))]),
   )
)
```

Das Ergebnis im PDF sieht dann so aus:

{% include figure popup=true image_path="/assets/images/typst-fibo.png" alt="Screenshot aus dem erzeugten PDF File" caption="Screenshot aus dem erzeugten PDF File"%}

Der Kanckpunkt ist jetzt eben, dass wir lediglich den Wert der Variablen `count` √§ndern m√ºssen, wenn wir mehr oder weniger Spalten und errechnete Fibonaccizahlen haben wollen. Wir m√ºssen niemals selbst die Fibonaccizahlen errechnen und "hard coded" in die Tabelle eintragen!

### Komplexeres Diagramm



üî≤
{:.qed}